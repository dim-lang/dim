A_DeclList@204 {
A_VarDecl@203x = A_i64_1@188 + A_i64_6@189 / - A_i64_3@190 * A_i64_4@193 + A_i64_3@194 % - A_i64_2@195
A_VarDecl@208y = A_i64_0@205
A_VarDecl@214z = A_id_x@209 + A_id_y@210
A_VarDecl@218a9 = A_i64_228@215
A_VarDecl@222a18 = A_f64_123.901000@219

A_FuncDecl_Hello@261() => {
	A_id_a@223=A_i64_1@224;
	A_id_b@228=A_i64_2@229;
	A_id_a@232=A_id_a@233 + A_id_b@234;
	A_return@239 A_id_a@238;
	if (A_id_a@240 < A_id_b@241) 
	A_Call_print@245(unknown node:[ @AstExpressionList size:1, 0:[ @AstIdentifierConstant value_:a ] ]); 
else 	A_Call_print@249(unknown node:[ @AstExpressionList size:1, 0:[ @AstIdentifierConstant value_:b ] ]);
	while (A_id_a@252 < A_id_b@253)
A_Call_print@257(unknown node:[ @AstExpressionList size:1, 0:[ @AstIdentifierConstant value_:a ] ]);
}


A_FuncDecl_ok@266() => {
	A_return@263 A_i64_0@262;
}


A_FuncDecl_testOnTokenLexer@281() => {
	A_Call_print@269(unknown node:[ @AstExpressionList size:1, 0:[ @AstStringConstant value_:This is going to be a very long string, which is used for testing coli DSL language ] ]);
	A_Call_print@274(unknown node:[ @AstExpressionList size:1, 0:[ @AstStringConstant value_:Since our language defines a string between double quotes, with new line break like this\n and this \r\n.
Let's see if it works as we expect.
Maybe we need more troubleshooting while testing. ] ]);
	A_Call_print@278(unknown node:[ @AstExpressionList size:1, 0:[ @AstStringConstant value_:Try punctuations like if \"'\" will stop this string literals.join string 2, join string 3, join string 4,  ] ]);
}

}
