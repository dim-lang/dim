#! /usr/bin/env bash
# Copyright 2019- <ac-lang>
# Apache License Version 2.0

ROOT=`pwd`
FOS=$(bash -c "echo \$OSTYPE")

function clean_all() {
    cd $ROOT
    rm *.log >>/dev/null 2>&1
    if [ -d debug ]; then cd debug && make clean && cd ..; fi
    if [ -d release ]; then cd release && make clean && cd ..; fi
}

function build_generate() {
    CATCH2_VERSION=v2.9.1
    SPDLOG_VERSION=v1.3.1
    FMTLIB_VERSION=5.3.0
    ENUM_VERSION=0.11.2
    cd $ROOT
    echo [ac] prepare catchorg/Catch2 $CATCH2_VERSION
    if [ ! -d test/Catch2 ]; then
        cd test && git clone -b $CATCH2_VERSION --single-branch --depth 1 https://github.com/catchorg/Catch2 && cd $ROOT
    fi
    echo [ac] prepare catchorg/Catch2 $CATCH2_VERSION - done
    echo [ac] prepare gabime/spdlog $SPDLOG_VERSION
    if [ ! -d src/spdlog ]; then
        cd src && git clone -b $SPDLOG_VERSION --single-branch --depth 1 https://github.com/gabime/spdlog && cd $ROOT
    fi
    echo [ac] prepare gabime/spdlog $SPDLOG_VERSION - done
    echo [ac] prepare fmtlib/fmt $FMTLIB_VERSION
    if [ ! -d src/fmt ]; then
        cd src && git clone -b $FMTLIB_VERSION --single-branch --depth 1 https://github.com/fmtlib/fmt && cd $ROOT
    fi
    echo [ac] prepare fmtlib/fmt $FMTLIB_VERSION - done
    echo [ac] prepare aantron/better-enums $ENUM_VERSION
    if [ ! -d src/better-enums ]; then
        cd src && git clone -b $ENUM_VERSION --single-branch --depth 1 https://github.com/aantron/better-enums.git && cd $ROOT
    fi
    echo [ac] prepare aantron/better-enums $ENUM_VERSION - done

    cd $ROOT/src
    if [ -f Token.yy.cpp ]; then rm Token.yy.cpp; fi
    if [ -f Parser.tab.hpp ]; then rm Parser.tab.hpp; fi
    if [ -f Parser.tab.cpp ]; then rm Parser.tab.cpp; fi
    if [ -f Parser.output ]; then rm Parser.output; fi
    case "$1" in
        release)
            flex -o Token.yy.cpp Token.l
            bison -o Parser.tab.cpp --defines=Parser.tab.hpp Parser.y
            ;;
        debug)
            flex -o Token.yy.cpp Token.l
            bison -v -o Parser.tab.cpp --defines=Parser.tab.hpp Parser.y
            ;;
        trace)
            flex --debug -o Token.yy.cpp Token.l
            bison --debug -v -o Parser.tab.cpp --defines=Parser.tab.hpp Parser.y
            ;;
        *)
            echo [ac] unknown build_generate argument "$1"
            exit 3
            ;;
    esac
}

function build_make() {
    cd $ROOT
    if [ "$1" == "release" ]; then
        if [ ! -d release ]; then mkdir release; fi
        cd release
        cmake -DCMAKE_BUILD_TYPE=Release .. && cmake --build . --config Release -- -j $2
    else
        if [ ! -d debug ]; then mkdir debug; fi
        cd debug
        cmake -DCMAKE_BUILD_TYPE=Debug -DCMAKE_VERBOSE_MAKEFILE=ON .. && cmake --build . --config Debug -- VERBOSE=1 -j $2
    fi
    cd $ROOT
}

# $1: trace/debug/release
# $2: job number
function build_routine() {
    case "$FOS" in
      solaris*) echo "[ac] solaris not support!" && exit 3 ;;
      darwin*)  ;;
      linux*)   ;;
      *bsd*)    ;;
      *)        echo "[ac] unknown os: $FOS!" && exit 3 ;;
    esac
    echo [ac] build for $FOS, mode=$1, job=$2
    build_generate $1
    build_make $1 $2
}

# $1: install path
function build_install() {
    case "$FOS" in
      solaris*) echo "[ac] solaris not support!" && exit 3 ;;
      darwin*)  ;;
      linux*)   ;;
      *bsd*)    ;;
      *)        echo "[ac] unknown os: $FOS!" && exit 3 ;;
    esac
    echo [ac] install for $FOS, INSTALL_PATH=$1
    cd $ROOT
    if [ ! -d release ]; then mkdir release; fi
    cd release
    cmake -DCMAKE_BUILD_TYPE=Release -DCMAKE_INSTALL_PREFIX==$1 .. && cmake --build . --config Release --target INSTALL -- -j $2
}

function build_help() {
    echo [ac] help message:
    echo   build -h/--help              - show help message.
    echo   build -r/--release           - build release.
    echo   build -d/--debug             - build debug.
    echo   build --trace                - build trace.
    echo   build -j/--job [n]           - build with [n] worker threads.
    echo   build -i/--install           - install, install path is /usr/local by default.
    echo   build -p/--path [path]       - custom install path.
    echo   build -t/--test              - run unit tests for debug/trace.
    echo   build -c/--clean             - clean objects.
}

# ---- main ----

BUILD_TYPE=release
BUILD_JOB=1
INSTALL=0
INSTALL_PATH=/usr/local

while [[ $# -gt 0 ]]; do
    key="$1"
    case $key in
        -h|--help)
            build_help
            exit 0
            ;;
        -c|--clean)
            clean_all
            exit 0
            ;;
        -t|--test)
            debug/test/ac-test
            exit 0
            ;;
        -d|--debug)
            BUILD_TYPE=debug
            shift
            ;;
        --trace)
            BUILD_TYPE=trace
            shift
            ;;
        -r|--release)
            BUILD_TYPE=release
            shift
            ;;
        -j|--job)
            shift
            BUILD_JOB=$1
            shift
            ;;
        -i|--install)
            INSTALL=1
            ;;
        -p|--path)
            shift
            INSTALL_PATH=$1
            shift
            ;;
        *)
            build_help
            exit 0
            ;;
    esac
done

build_routine $BUILD_TYPE $BUILD_JOB
if [[ $INSTALL -gt 0 ]]; then
    build_install $INSTALL_PATH
fi
