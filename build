#! /usr/bin/env bash
# Copyright 2019- <nerd-lang>
# Apache License Version 2.0

ROOT=`pwd`
FOS=$(bash -c "echo \$OSTYPE")

function check_return() {
    if [ $1 -ne 0 ]; then
        echo [nerd] $2
        exit $1
    fi
}

function clean_all() {
    cd $ROOT
    rm *.log >>/dev/null 2>&1
    if [ -d debug ]; then cd debug && make clean && cd ..; fi
    if [ -d release ]; then cd release && make clean && cd ..; fi
}

function build_dependency() {
    CATCH2_VERSION=v2.9.1
    SPDLOG_VERSION=v1.3.1
    FMTLIB_VERSION=5.3.0
    ENUM_VERSION=0.11.2
    cd $ROOT
    echo [nerd] prepare catchorg/Catch2 $CATCH2_VERSION
    if [ ! -d test/Catch2 ]; then
        cd test && git clone -b $CATCH2_VERSION --single-branch --depth 1 https://github.com/catchorg/Catch2 && cd $ROOT
    fi
    echo [nerd] prepare catchorg/Catch2 $CATCH2_VERSION - done
    echo [nerd] prepare gabime/spdlog $SPDLOG_VERSION
    if [ ! -d src/spdlog ]; then
        cd src && git clone -b $SPDLOG_VERSION --single-branch --depth 1 https://github.com/gabime/spdlog && cd $ROOT
    fi
    echo [nerd] prepare gabime/spdlog $SPDLOG_VERSION - done
    echo [nerd] prepare fmtlib/fmt $FMTLIB_VERSION
    if [ ! -d src/fmt ]; then
        cd src && git clone -b $FMTLIB_VERSION --single-branch --depth 1 https://github.com/fmtlib/fmt && cd $ROOT
    fi
    echo [nerd] prepare fmtlib/fmt $FMTLIB_VERSION - done
    echo [nerd] prepare aantron/better-enums $ENUM_VERSION
    if [ ! -d src/better-enums ]; then
        cd src && git clone -b $ENUM_VERSION --single-branch --depth 1 https://github.com/aantron/better-enums && cd $ROOT
    fi
    echo [nerd] prepare aantron/better-enums $ENUM_VERSION - done
}

function build_make() {
    cd $ROOT
    if [ "$1" == "release" ]; then
        cmake -DCMAKE_BUILD_TYPE=Release -B release
        cd release && cmake --build . --config Release
    else
        cmake -DCMAKE_BUILD_TYPE=Debug -DCMAKE_VERBOSE_MAKEFILE=ON -B debug
        cd debug && cmake --build . --config Debug -- VERBOSE=1
    fi
    cd $ROOT
}

# $1: debug/release
function build_routine() {
    case "$FOS" in
      solaris*) ;;
      darwin*)  ;;
      linux*)   ;;
      *bsd*)    ;;
      *)        echo "[nerd] unknown os: $FOS!" && exit 3 ;;
    esac
    echo [nerd] build for $FOS, mode=$1
    build_dependency $1
    build_make $1
}

# $1: install path
function build_install() {
    case "$FOS" in
      solaris*) ;;
      darwin*)  ;;
      linux*)   ;;
      *bsd*)    ;;
      *)        echo "[nerd] unknown os: $FOS!" && exit 3 ;;
    esac
    echo [nerd] install for $FOS, path=$1
    cd $ROOT
    if [ ! -d release ]; then mkdir release; fi
    cmake -DCMAKE_BUILD_TYPE=Release -DCMAKE_INSTALL_PREFIX==$1 -B release
    cd release && cmake --build . --config Release --target INSTALL
}

function build_graph() {
    cd test/case
    for f in *
    do
        if [ ${f: -4} == ".dot" ]; then
            echo [nerd] generate $f.png for $f
            dot -Tpng $f -o $f.png
        fi
    done
}

function build_help() {
    echo '[nerd] build help message:'
    echo 'usage:'
    echo '  build -r/--release              build release.'
    echo '  build -d/--debug                build debug.'
    echo '  build -p/--parser               generate tokenizer and parser.'
    echo '  build [option] -i/--install     install with [--path] option.'
    echo '  build -t/--test                 run unit tests in debug mode.'
    echo '  build -c/--clean                clean objects.'
    echo 'option:'
    echo '  --path                          config install path prefix, by default is /usr/local.'
    echo 'flag:'
    echo '  build -h/--help                 show help message.'
}

# ---- main ----

BUILD_TYPE=release
INSTALL=0
INSTALL_PATH=/usr/local

while [[ $# -gt 0 ]]; do
    key="$1"
    case $key in
        -h|--help)
            build_help
            exit 0
            ;;
        -c|--clean)
            clean_all
            exit 0
            ;;
        -t|--test)
            debug/nerd-test
            exit 0
            ;;
        --parser)
            cd src
            flex --debug -o tokenizer.yy.cc --header-file=tokenizer.yy.hh tokenizer.l
            bison --debug -v -o parser.tab.cc --defines=parser.tab.hh parser.y
            exit 0
            ;;
        -g|--graph)
            build_graph
            exit 0
            ;;
        -d|--debug)
            BUILD_TYPE=debug
            shift
            ;;
        -r|--release)
            BUILD_TYPE=release
            shift
            ;;
        -i|--install)
            INSTALL=1
            ;;
        -p|--path)
            shift
            INSTALL_PATH=$1
            shift
            ;;
        *)
            build_help
            exit 0
            ;;
    esac
done

build_routine $BUILD_TYPE
if [[ $INSTALL -gt 0 ]]; then
    build_install $INSTALL_PATH
fi
