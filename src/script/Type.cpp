// Copyright 2019- <fastype.org>
// Apache License Version 2.0

#include "script/Type.h"
#include "Hasher.h"
#include "exception/ScriptException.h"

namespace fastype {

icu::UnicodeString Type::name(int value) {
  switch (value) {
    // token type
  case F_TYPE_EOF:
    return UNICODE_STRING_SIMPLE("EOF");
  case F_TYPE_INTEGER:
    return UNICODE_STRING_SIMPLE("INTEGER");
  case F_TYPE_FLOATING:
    return UNICODE_STRING_SIMPLE("FLOATING");
  case F_TYPE_OPERATOR:
    return UNICODE_STRING_SIMPLE("OPERATOR");
  case F_TYPE_COMPARATOR:
    return UNICODE_STRING_SIMPLE("COMPARATOR");
  case F_TYPE_ASSIGNMENT:
    return UNICODE_STRING_SIMPLE("ASSIGNMENT");
  case F_TYPE_BOOLEAN:
    return UNICODE_STRING_SIMPLE("BOOLEAN");
  case F_TYPE_IDENTIFIER:
    return UNICODE_STRING_SIMPLE("IDENTIFIER");
  case F_TYPE_PUNCTUATION:
    return UNICODE_STRING_SIMPLE("PUNCTUATION");
  case F_TYPE_KEYWORD:
    return UNICODE_STRING_SIMPLE("KEYWORD");
  case F_TYPE_STRING:
    return UNICODE_STRING_SIMPLE("STRING");

    // ast type
  case F_TYPE_PROGRAM:
    return UNICODE_STRING_SIMPLE("PROGRAM");
  case F_TYPE_STATEMENT_LIST:
    return UNICODE_STRING_SIMPLE("STATEMENT_LIST");
  case F_TYPE_DECLARATION:
    return UNICODE_STRING_SIMPLE("DECLARATION");
  case F_TYPE_STATEMENT:
    return UNICODE_STRING_SIMPLE("STATEMENT");
  case F_TYPE_VARIABLE_DECLARATION:
    return UNICODE_STRING_SIMPLE("VARIABLE_DECLARATION");
  case F_TYPE_FUNCTION_DECLARATION:
    return UNICODE_STRING_SIMPLE("FUNCTION_DECLARATION");
  case F_TYPE_CLASS_DECLARATION:
    return UNICODE_STRING_SIMPLE("CLASS_DECLARATION");
  case F_TYPE_COMPOUND_STATEMENT:
    return UNICODE_STRING_SIMPLE("COMPOUND_STATEMENT");
  case F_TYPE_ASSIGNMENT_STATEMENT:
    return UNICODE_STRING_SIMPLE("ASSIGNMENT_STATEMENT");
  case F_TYPE_EMPTY_STATEMENT:
    return UNICODE_STRING_SIMPLE("EMPTY_STATEMENT");
  case F_TYPE_RETURN_STATEMENT:
    return UNICODE_STRING_SIMPLE("RETURN_STATEMENT");
  case F_TYPE_BINARY_OP:
    return UNICODE_STRING_SIMPLE("BINARY_OP");
  case F_TYPE_UNARY_OP:
    return UNICODE_STRING_SIMPLE("UNARY_OP");
  case F_TYPE_VARIABLE:
    return UNICODE_STRING_SIMPLE("VARIABLE");
  case F_TYPE_INTEGER_CONSTANT:
    return UNICODE_STRING_SIMPLE("INTEGER_CONSTANT");
  case F_TYPE_FLOATING_CONSTANT:
    return UNICODE_STRING_SIMPLE("FLOATING_CONSTANT");
  case F_TYPE_BOOLEAN_CONSTANT:
    return UNICODE_STRING_SIMPLE("BOOLEAN_CONSTANT");
  case F_TYPE_STRING_CONSTANT:
    return UNICODE_STRING_SIMPLE("STRING_CONSTANT");
  default:
    F_THROW(ScriptException, "type value not found:{}", value);
  }
}

std::string Type::nameUTF8(int value) {
  std::string _1;
  return name(value).toUTF8String(_1);
}

int Type::value(const icu::UnicodeString &name) {
  static const std::unordered_map<icu::UnicodeString, int> typeMapping = {
      // token type
      {UNICODE_STRING_SIMPLE("EOF"), F_TYPE_EOF},
      {UNICODE_STRING_SIMPLE("INTEGER"), F_TYPE_INTEGER},
      {UNICODE_STRING_SIMPLE("FLOATING"), F_TYPE_FLOATING},
      {UNICODE_STRING_SIMPLE("OPERATOR"), F_TYPE_OPERATOR},
      {UNICODE_STRING_SIMPLE("COMPARATOR"), F_TYPE_COMPARATOR},
      {UNICODE_STRING_SIMPLE("ASSIGNMENT"), F_TYPE_ASSIGNMENT},
      {UNICODE_STRING_SIMPLE("BOOLEAN"), F_TYPE_BOOLEAN},
      {UNICODE_STRING_SIMPLE("IDENTIFIER"), F_TYPE_IDENTIFIER},
      {UNICODE_STRING_SIMPLE("PUNCTUATION"), F_TYPE_PUNCTUATION},
      {UNICODE_STRING_SIMPLE("KEYWORD"), F_TYPE_KEYWORD},
      {UNICODE_STRING_SIMPLE("STRING"), F_TYPE_STRING},
      // ast type
      {UNICODE_STRING_SIMPLE("PROGRAM"), F_TYPE_PROGRAM},
      {UNICODE_STRING_SIMPLE("STATEMENT_LIST"), F_TYPE_STATEMENT_LIST},
      {UNICODE_STRING_SIMPLE("DECLARATION"), F_TYPE_DECLARATION},
      {UNICODE_STRING_SIMPLE("STATEMENT"), F_TYPE_STATEMENT},
      {UNICODE_STRING_SIMPLE("VARIABLE_DECLARATION"),
       F_TYPE_VARIABLE_DECLARATION},
      {UNICODE_STRING_SIMPLE("FUNCTION_DECLARATION"),
       F_TYPE_FUNCTION_DECLARATION},
      {UNICODE_STRING_SIMPLE("CLASS_DECLARATION"), F_TYPE_CLASS_DECLARATION},
      {UNICODE_STRING_SIMPLE("COMPOUND_STATEMENT"), F_TYPE_COMPOUND_STATEMENT},
      {UNICODE_STRING_SIMPLE("ASSIGNMENT_STATEMENT"),
       F_TYPE_ASSIGNMENT_STATEMENT},
      {UNICODE_STRING_SIMPLE("EMPTY_STATEMENT"), F_TYPE_EMPTY_STATEMENT},
      {UNICODE_STRING_SIMPLE("RETURN_STATEMENT"), F_TYPE_RETURN_STATEMENT},
      {UNICODE_STRING_SIMPLE("BINARY_OP"), F_TYPE_BINARY_OP},
      {UNICODE_STRING_SIMPLE("UNARY_OP"), F_TYPE_UNARY_OP},
      {UNICODE_STRING_SIMPLE("VARIABLE"), F_TYPE_VARIABLE},
      {UNICODE_STRING_SIMPLE("INTEGER_CONSTANT"), F_TYPE_INTEGER_CONSTANT},
      {UNICODE_STRING_SIMPLE("FLOATING_CONSTANT"), F_TYPE_FLOATING_CONSTANT},
      {UNICODE_STRING_SIMPLE("BOOLEAN_CONSTANT"), F_TYPE_BOOLEAN_CONSTANT},
      {UNICODE_STRING_SIMPLE("STRING_CONSTANT"), F_TYPE_STRING_CONSTANT},
  };
  std::unordered_map<icu::UnicodeString, int>::const_iterator it =
      typeMapping.find(name);
  if (it == typeMapping.end()) {
    std::string _1;
    F_THROW(ScriptException, "type name not found:{}", name.toUTF8String(_1));
  }
  return it->second;
}

} // namespace fastype
